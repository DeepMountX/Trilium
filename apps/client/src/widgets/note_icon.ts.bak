import { t } from "../services/i18n.js";
import NoteContextAwareWidget from "./note_context_aware_widget.js";
import attributeService from "../services/attributes.js";
import server from "../services/server.js";
import type FNote from "../entities/fnote.js";
import type { EventData } from "../components/app_context.js";
import type { Icon } from "./icon_list.js";
import { Dropdown } from "bootstrap";

export default class NoteIconWidget extends NoteContextAwareWidget {

    private dropdown!: bootstrap.Dropdown;
    private $icon!: JQuery<HTMLElement>;
    private $iconList!: JQuery<HTMLElement>;
    private $iconCategory!: JQuery<HTMLElement>;
    private $iconSearch!: JQuery<HTMLElement>;

    doRender() {
        this.$icon = this.$widget.find("button.note-icon");
        this.$iconList = this.$widget.find(".icon-list");
        this.$iconList.on("click", "span", async (e) => {
            const clazz = $(e.target).attr("class");

            if (this.noteId && this.note) {
                await attributeService.setLabel(this.noteId, this.note.hasOwnedLabel("workspace") ? "workspaceIconClass" : "iconClass", clazz);
            }
        });

        this.$iconCategory = this.$widget.find("select[name='icon-category']");
        this.$iconCategory.on("change", () => this.renderDropdown());
        this.$iconCategory.on("click", (e) => e.stopPropagation());

        this.$iconSearch = this.$widget.find("input[name='icon-search']");
        this.$iconSearch.on("input", () => this.renderDropdown());

        this.$widget.on("show.bs.dropdown", async () => {
            const { categories } = (await import("./icon_list.js")).default;

            this.$iconCategory.empty();

            for (const category of categories) {
                this.$iconCategory.append($("<option>").text(category.name).attr("value", category.id));
            }

            this.$iconSearch.val("");

            this.renderDropdown();
        });
    }

    async refreshWithNote(note: FNote) {
        this.$icon.removeClass().addClass(`${note.getIcon()} note-icon`);
        this.$icon.prop("disabled", !!(this.noteContext?.viewScope?.viewMode !== "default"));
        this.dropdown.hide();
    }

    async entitiesReloadedEvent({ loadResults }: EventData<"entitiesReloaded">) {
        if (this.noteId && loadResults.isNoteReloaded(this.noteId)) {
            this.refresh();
            return;
        }

        for (const attr of loadResults.getAttributeRows()) {
            if (attr.type === "label" && ["iconClass", "workspaceIconClass"].includes(attr.name ?? "") && attributeService.isAffecting(attr, this.note)) {
                this.refresh();
                break;
            }
        }
    }

    async renderDropdown() {
        this.$iconList.empty();

        if (this.getIconLabels().length > 0) {
            this.$iconList.append(
                $(`<div style="text-align: center">`).append(
                    $(`<button class="btn btn-sm">${t("note_icon.reset-default")}</button>`).on("click", () =>
                        this.getIconLabels().forEach((label) => {
                            if (this.noteId) {
                                attributeService.removeAttributeById(this.noteId, label.attributeId);
                            }
                        })
                    )
                )
            );
        }

        const categoryId = parseInt(String(this.$iconCategory.find("option:selected")?.val()));
        const search = String(this.$iconSearch.val())?.trim()?.toLowerCase();

        const filteredIcons = icons.filter((icon) => {
            if (categoryId && icon.category_id !== categoryId) {
                return false;
            }

            if (search) {
                if (!icon.name.includes(search) && !icon.term?.find((t) => t.includes(search))) {
                    return false;
                }
            }

            return true;
        });

        if (iconToCount) {
            filteredIcons.sort((a, b) => {
                const countA = iconToCount[a.className ?? ""] || 0;
                const countB = iconToCount[b.className ?? ""] || 0;

                return countB - countA;
            });
        }

        for (const icon of filteredIcons) {
            this.$iconList.append(this.renderIcon(icon));
        }

        this.$iconSearch.focus();
    }

    getIconLabels() {
        if (!this.note) {
            return [];
        }
        return this.note.getOwnedLabels().filter((label) => ["workspaceIconClass", "iconClass"].includes(label.name));
    }
}
